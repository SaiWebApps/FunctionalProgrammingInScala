# Huffman Coding

## Context
A Huffman code can be represented by a binary tree whose leaves represent the characters that should be encoded.
The code tree below can represent the characters A to H.
![](https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/9JcZmiZJEeaqsg6VQGUNXQ_3714009374b825507d45d2c4d74e5651_huffman-table.png?expiry=1611532800000&hmac=g6rl6G_gdkmpj46wPic1_fcQNxa97mDt68jilOlX2fc)

The leaf nodes have associated with them a weight which denotes the frequency of appearance of that character.
In the example below, the character A has the highest weight 8, while F for example has weight 1.

Every branching node of the code tree is essentially a set containing the characters present in the leaves below it.
The weight of a branching node is the total weight of the leaves below it: this information is necessary for the
construction of the tree.

Note that a given encoding is only optimal if the character frequencies in the encoded text match the weights in the code tree.

Finally, observe the recursive structure of the coding tree: every sub-tree is itself a valid code tree for a smaller alphabet.

### Encoding
For a given Huffman tree, one can obtain the encoded representation of a character by traversing from the root of the
tree to the leaf containing the character. Along the way, when a left branch is chosen, a 0 is added to the
representation, and when a right branch is chosen, 1 is added to the representation. Thus, for the Huffman tree above,
the character D is encoded as 1011.

### Decoding
Decoding also starts at the root of the tree. Given a sequence of bits to decode, we successively read the bits, and
for each 0, we choose the left branch, and for each 1 we choose the right branch. When we reach a leaf, we decode the
corresponding character and then start again at the root of the tree. As an example, given the Huffman tree above,
the sequence of bits,10001010 corresponds to BAC.

### CodeTree Structure
For this assignment, we are representing Huffman Trees as follows:
```scala
abstract class CodeTree
case class Fork (left: CodeTree, right: CodeTree, chars: List[Char], weight: Int) extends CodeTree
case class Leaf(char: Char, weight: Int) extends CodeTree
```

We have also provided several utility functions to get you started off:
```scala
def weight(tree: CodeTree): Int
def chars(tree: CodeTree): Int
def makeCodeTree(left: CodeTree, right: CodeTree)
```

## Part 1: Generate a char frequency table for a list of characters.
Implement the method **times**:
```scala
def times(chars: List[Char]): List[(Char, Int)]
```
This should return a List of 2-Tuples, where each pair represents a character from chars and the number of times that
it occurs within chars.

E.g., for `chars = "abbad"`, **times** should return `[('a', 2), ('b', 2), ('d', 1)]`.

## Part 2: Convert frequency table into an ordered list of `Leaf`s.
Implement
```scala
def makeOrderedLeafList(freqs: List[(Char, Int)]): List[Leaf]
```
to convert a given frequency table (as generated by **times** above) into an ordered List of `Leaf`s. Note that the
final result should be sorted in ascending order by weight and then by character. In other words, first priority for
sorting should go to weight, and if two nodes have the same weight, then sort in ascending order by character.

## Part 3: Singleton
This one's super easy - just determine whether or not the given `List[CodeTree]` has a single `CodeTree`.
```scala
def singleton(trees: List[CodeTree]): Boolean
```

## Part 4: Combine
Implement
```scala
def combine(trees: List[CodeTree]): List[CodeTree]
```
to remove the first two code trees in the given list of `CodeTree`s; combine them; add them back into trees; and
resort trees in ascending order by weight (1st) and character (2nd).

## Part 5: Until
Write a function until which calls the two functions defined above until this list contains only a single tree.
This tree is the optimal coding tree. The function until can be used in the following way:
```scala
until(singleton, combine)(trees)
```
where the argument trees is of the type List[CodeTree].

## Part 6: Create CodeTree from List[Chars].
Implement
```scala
def createCodeTree(chars: List[Char]): CodeTree
```
using the previously implemented methods above.